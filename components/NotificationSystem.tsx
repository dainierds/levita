
import React, { createContext, useContext, useState, useEffect } from 'react';
import { AppNotification, NotificationType } from '../types';
import { Bell, X, CheckCircle, AlertCircle, Info, Trash2 } from 'lucide-react';

interface NotificationContextType {
  notifications: AppNotification[];
  unreadCount: number;
  addNotification: (type: NotificationType, title: string, message: string, targetUserId?: string) => void;
  markAsRead: (id: string) => void;
  markAllAsRead: () => void;
  removeNotification: (id: string) => void;
}

const NotificationContext = createContext<NotificationContextType | undefined>(undefined);

export const useNotification = () => {
  const context = useContext(NotificationContext);
  if (!context) {
    throw new Error('useNotification must be used within a NotificationProvider');
  }
  return context;
};

interface NotificationProviderProps {
  children: React.ReactNode;
  allNotifications: AppNotification[];
  setAllNotifications: React.Dispatch<React.SetStateAction<AppNotification[]>>;
  currentUserId?: string; // Used to filter what this user sees
}

export const NotificationProvider: React.FC<NotificationProviderProps> = ({ 
  children, 
  allNotifications, 
  setAllNotifications,
  currentUserId 
}) => {
  
  // Filter notifications relevant to the current user
  const userNotifications = allNotifications.filter(n => {
    // If targeted to 'ALL', everyone sees it
    if (n.targetUserId === 'ALL') return true;
    // If targeted to specific ID, only that user sees it
    if (n.targetUserId && n.targetUserId === currentUserId) return true;
    // If no target specified (legacy/system local), assume it's for current session (or you might choose to show to all)
    // For this implementation, let's assume undefined target is 'local' or 'current session' which we might handle differently,
    // but for simplicity, let's treat undefined as "only visible to the creator" if we had session logic, 
    // or just "visible to all" if generated by system events. 
    // Let's stick to: undefined = current session only (not persisted globally usually, but here we persist).
    // Better logic: undefined = 'ALL' implicitly for system messages like "Saved successfully".
    return !n.targetUserId; 
  });

  const addNotification = (type: NotificationType, title: string, message: string, targetUserId?: string) => {
    const newNotification: AppNotification = {
      id: Math.random().toString(36).substr(2, 9),
      title,
      message,
      type,
      timestamp: new Date(),
      read: false,
      targetUserId: targetUserId
    };
    setAllNotifications((prev) => [newNotification, ...prev]);
  };

  const markAsRead = (id: string) => {
    setAllNotifications((prev) =>
      prev.map((n) => (n.id === id ? { ...n, read: true } : n))
    );
  };

  const markAllAsRead = () => {
    setAllNotifications((prev) => 
      prev.map((n) => {
        // Only mark read if it belongs to this user view
        if (n.targetUserId === 'ALL' || n.targetUserId === currentUserId || !n.targetUserId) {
            return { ...n, read: true };
        }
        return n;
      })
    );
  };

  const removeNotification = (id: string) => {
    setAllNotifications((prev) => prev.filter((n) => n.id !== id));
  };

  const unreadCount = userNotifications.filter((n) => !n.read).length;

  return (
    <NotificationContext.Provider
      value={{
        notifications: userNotifications,
        unreadCount,
        addNotification,
        markAsRead,
        markAllAsRead,
        removeNotification,
      }}
    >
      {children}
      <NotificationToasts notifications={userNotifications} removeNotification={removeNotification} />
    </NotificationContext.Provider>
  );
};

// --- COMPONENTS ---

export const NotificationBell: React.FC = () => {
  const { notifications, unreadCount, markAllAsRead, markAsRead, removeNotification } = useNotification();
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div className="relative z-50">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="relative p-2 rounded-full hover:bg-slate-100 transition-colors text-slate-500 hover:text-indigo-600"
      >
        <Bell size={24} />
        {unreadCount > 0 && (
          <span className="absolute top-1 right-1 w-3 h-3 bg-red-500 border-2 border-white rounded-full"></span>
        )}
      </button>

      {isOpen && (
        <>
          <div
            className="fixed inset-0 z-40"
            onClick={() => setIsOpen(false)}
          ></div>
          <div className="absolute right-0 mt-2 w-80 md:w-96 bg-white rounded-3xl shadow-2xl border border-slate-100 z-50 overflow-hidden animate-in fade-in zoom-in-95 duration-200">
            <div className="p-4 border-b border-slate-50 flex justify-between items-center bg-slate-50/50">
              <h3 className="font-bold text-slate-800">Notificaciones</h3>
              {unreadCount > 0 && (
                <button
                  onClick={markAllAsRead}
                  className="text-xs font-bold text-indigo-600 hover:text-indigo-800"
                >
                  Marcar le√≠das
                </button>
              )}
            </div>
            <div className="max-h-[400px] overflow-y-auto">
              {notifications.length === 0 ? (
                <div className="p-8 text-center text-slate-400">
                  <Bell className="mx-auto mb-2 opacity-20" size={32} />
                  <p className="text-sm">No tienes notificaciones nuevas.</p>
                </div>
              ) : (
                notifications.map((n) => (
                  <div
                    key={n.id}
                    className={`p-4 border-b border-slate-50 hover:bg-slate-50 transition-colors flex gap-3 group relative ${
                      !n.read ? 'bg-indigo-50/30' : ''
                    }`}
                    onClick={() => markAsRead(n.id)}
                  >
                    <div className={`mt-1 ${
                        n.type === 'success' ? 'text-green-500' :
                        n.type === 'error' ? 'text-red-500' :
                        n.type === 'warning' ? 'text-orange-500' : 'text-indigo-500'
                    }`}>
                        {n.type === 'success' && <CheckCircle size={16} />}
                        {n.type === 'error' && <AlertCircle size={16} />}
                        {n.type === 'warning' && <AlertCircle size={16} />}
                        {n.type === 'info' && <Info size={16} />}
                    </div>
                    <div className="flex-1 pr-6">
                        <h4 className={`text-sm font-bold ${!n.read ? 'text-slate-800' : 'text-slate-500'}`}>
                            {n.title}
                        </h4>
                        <p className="text-xs text-slate-500 mt-1 leading-snug">{n.message}</p>
                        <span className="text-[10px] text-slate-400 mt-2 block">
                            {n.timestamp.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                        </span>
                    </div>
                    <button 
                        onClick={(e) => { e.stopPropagation(); removeNotification(n.id); }}
                        className="absolute right-2 top-2 p-1 text-slate-300 hover:text-red-400 opacity-0 group-hover:opacity-100 transition-opacity"
                    >
                        <Trash2 size={14} />
                    </button>
                    {!n.read && (
                        <div className="absolute right-4 top-1/2 -translate-y-1/2 w-2 h-2 bg-indigo-500 rounded-full"></div>
                    )}
                  </div>
                ))
              )}
            </div>
          </div>
        </>
      )}
    </div>
  );
};

const NotificationToasts: React.FC<{notifications: AppNotification[], removeNotification: (id: string) => void}> = ({notifications, removeNotification}) => {
  const [toasts, setToasts] = useState<AppNotification[]>([]);

  useEffect(() => {
    if (notifications.length > 0) {
        // Get the latest notification
        const latest = notifications[0];
        // Only show if it is very recent (created in last 2 seconds) to avoid showing old ones on refresh
        const isRecent = (new Date().getTime() - new Date(latest.timestamp).getTime()) < 2000;
        
        if (isRecent && !toasts.find(t => t.id === latest.id)) {
            setToasts(prev => [latest, ...prev].slice(0, 3));
            setTimeout(() => {
                setToasts(prev => prev.filter(t => t.id !== latest.id));
            }, 4000);
        }
    }
  }, [notifications.length]); // Dependency on length change implies new item

  return (
    <div className="fixed top-4 right-4 z-[100] flex flex-col gap-2 w-full max-w-sm pointer-events-none">
      {toasts.map((n) => (
        <div
          key={n.id}
          className={`
            pointer-events-auto bg-white p-4 rounded-2xl shadow-xl border border-slate-100 
            flex items-start gap-3 animate-in slide-in-from-right-10 fade-in duration-300
          `}
        >
           <div className={`mt-0.5 ${
                n.type === 'success' ? 'text-green-500' :
                n.type === 'error' ? 'text-red-500' :
                n.type === 'warning' ? 'text-orange-500' : 'text-indigo-500'
            }`}>
                {n.type === 'success' && <CheckCircle size={20} />}
                {n.type === 'error' && <AlertCircle size={20} />}
                {n.type === 'warning' && <AlertCircle size={20} />}
                {n.type === 'info' && <Info size={20} />}
            </div>
            <div className="flex-1">
                <h4 className="font-bold text-slate-800 text-sm">{n.title}</h4>
                <p className="text-xs text-slate-500">{n.message}</p>
            </div>
            <button 
                onClick={() => setToasts(prev => prev.filter(t => t.id !== n.id))}
                className="text-slate-300 hover:text-slate-500"
            >
                <X size={16} />
            </button>
        </div>
      ))}
    </div>
  );
};
